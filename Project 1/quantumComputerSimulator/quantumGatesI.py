######################## Libraries and Files ######################### Librariesimport numpy as np# Filesfrom diracNotation.conversion import *from diracNotation.prettyPrint import *####################### Function defintion ######################## Performs recursive kron to get correct-sized matrix.# This will perform a tensor multiplication which will# resize the matrix to the correct size in order for# matrix-vector multiplication work.# In summary, it will multiply identity matrices and the# gate matrix in order (so the gate matrix multiplication# will appear) on the spot of the wire.def tensorMultiplication(wire, numberOfWires, gate):    # Create identity matrix:    identity = np.identity(len(gate))        # Start by saying product is identity.    product = identity    # If the last wire contains the gate, start    # product to being the gate, and then perform    # tensor multiplication by identity matrices.    if (numberOfWires - 1) == wire:        product = gate    # Iterate through every wire with the following    # iterator:    i = numberOfWires - 2        # While we still have wires:    while i >= 0:        # This wire has the gate. Multiply it by        # gate matrix.        if i == wire:            product = np.kron(gate, product)        # This wire does not have the gate. Multiply        # it by identity matrix.        else:            product = np.kron(identity, product)                # Decrement.        i -= 1            return productdef CNOTtensorMultiplication(wire1, wire2, numberOfWires, gate):    # Create 2x2 identity matrix:    identity = np.identity(2)    found_once = False        # Start by saying product is identity.    product = identity    # If the last wire contains the gate, start    # product to being the gate, and then perform    # tensor multiplication by identity matrices.    if (numberOfWires - 1) == wire1 or (numberOfWires - 1) == wire2:        product = gate        found_once = True    # Iterate through every wire with the following    # iterator:    i = numberOfWires - 2        # While we still have wires:    while i >= 0:        # This wire has the gate. Multiply it by        # gate matrix.        if i == wire1 or i == wire2:            if found_once == False:                product = np.kron(gate, product)                found_once = True        # This wire does not have the gate. Multiply        # it by identity matrix.        else:            product = np.kron(identity, product)                # Decrement.        i -= 1            return product# Computes the next state given the hadamard gate.def hadamard(wire, inputState):    # Get number of wires:    numberOfWires = len(inputState[0][1])    if wire >= numberOfWires:        print("Could not perform action. Wire out of bounds.")        return inputState        # Create hadamard matrix:    hadamard = (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]])        # Resize it to the correct shape:    hadamard = tensorMultiplication(wire, numberOfWires, hadamard)        # Turn from state to vector:    vector = stateToVector(inputState)    vector = np.array(vector)        # Matrix product between hadamard and vector:    product = np.matmul(hadamard, vector)        # Create new state:        newState = vectorToState(product)    print("hadamard:      ", prettyPrintInteger(newState))    return newState    # Computes the next state given the phase gate.def phase(wire, theta, inputState):    # Get number of wires:    numberOfWires = len(inputState[0][1])    if wire >= numberOfWires:        print("Could not perform action. Wire out of bounds.")        return inputState        # Create phase matrix:    phase = np.array([[1, 0], [0, np.exp(theta * 1.j)]])        # Resize it to the correct shape:    phase = tensorMultiplication(wire, numberOfWires, phase)        # Turn from state to vector:    vector = stateToVector(inputState)    vector = np.array(vector)    # Matrix product between phase and vector:    product = np.matmul(phase, vector)        # Create new state:        newState = vectorToState(product)    print("phase:         ", prettyPrintInteger(newState))    return newState# Computes the next state given the CNOT gate.def controlledNot(controlWire, notWire, inputState):    # Get number of wires:    numberOfWires = len(inputState[0][1])    if controlWire >= numberOfWires or notWire >= numberOfWires:        print("Could not perform action. Wire out of bounds.")        return inputState        # Create controlled not matrix:    controlledNot = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])        # # Resize it to the correct shape:    controlledNot = CNOTtensorMultiplication(controlWire, notWire, numberOfWires, controlledNot)        # Turn from state to vector:    vector = stateToVector(inputState)    vector = np.array(vector)    # Matrix product between phase and vector:    product = np.matmul(controlledNot, vector)        # Create new state:        newState = vectorToState(product)        print("controlled-not:", prettyPrintInteger(newState))    return newStatedef fullCircuit(inputState, quantumCircuit):    # Number of wires    wires = quantumCircuit[0]        new_state = inputState.copy()    # Gates:    for gate in quantumCircuit[1:]:        if gate[0] == 'H':            new_state = hadamard(gate[1], new_state)        elif gate[0] == 'P':            new_state = phase(gate[1], gate[2], new_state)        elif gate[0] == 'CNOT':            new_state = controlledNot(gate[1], gate[2], new_state)                return new_state##################################################state = [[1, '000']]quantumCircuit = [[3],                 ['H', 1],                 ['H', 2],                 ['P', 2, 0.3],                 ['CNOT', 2, 1],                 ['H', 1],                 ['H', 2],                 ['CNOT', 2, 0]]fullCircuit(state, quantumCircuit)